---
layout: default
title: "Opensource Libraries We've Created and How We Use Them (Part Two Point Two: HTTP Testability)"
short_title: "Opensource Libraries We've Created and How We Use Them (Part 2.2)"
author:
    name: Jon Cram
    url: http://webignition.net
---

<div class="section">
    <p>
        I created some libraries for dealing with certain matters that would be common
        across the Simply Testable service.
    </p>
    <p>
        Such libraries address generic matters that should be useful to others. They
        have been opensource under an MIT license from day one.
    </p>     
    <p>
        In <a href="/opensource-libraries-weve-created-and-how-we-use-them-part-one-url-handling/">part one of this series</a>,
        I talked about what we use for handling URLs.
        In <a href="/opensource-libraries-weve-created-and-how-we-use-them-part-two-point-one-http-reliability/">part two point one of this series</a>,
        I talked about how we deal with many HTTP requests reliably.
    </p>
    <p>
        In part two point two, I look at how we unit test HTTP-based applications
        whilst avoiding the ways in which HTTP can fail.
    </p>
    <h2>Unit Testing HTTP-based Applications Without Unexpected HTTP Failure</h2>
    <ul class="repository-list">
        <li>
            <i class="icon-github"></i>
            <a href="https://github.com/webignition/http-client">webignition/http-client</a>
            <a class="build-status" href="http://travis-ci.org/webignition/http-client"><img src="https://secure.travis-ci.org/webignition/http-client.png?branch=master" /></a>            
        </li>      
    </ul>    
    <p>
        In <a href="/http-failures-and-what-to-test-for-in-http-applications/">&ldquo;HTTP Failures And What To Test For In HTTP Applications&rdquo;</a>
        I introduced the means by which HTTP conversations can fail and the common 
        cases you need to cover to ensure your application is resilient:
    </p>    
    <ul>
        <li>
            <p>Invalid URL format</p>
        </li>
        <li>
            <p>DNS resolution failure</p>
        </li>
        <li>
            <p>Connection or transfer timeout</p>
        </li>        
    </ul>
    <p>
        To be sure you deal correctly with these failure conditions, as well as 
        ensuring that you avoid such conditions when you're expecting code to
        behave predictably during unit tests, you need a means of receiving
        consistent responses or generating expected failure scenarios.
    </p>     
    <h2>Achieving Consistency in HTTP Conversations</h2>
   
    <p>
        If you want to consistently receive an expected successful HTTP response 
        for a given HTTP request you need to hard-code the desired response.
        Similarly if you want to consistently encounter a predictable HTTP failure
        condition for an HTTP request you need to hard-code the conditions for the 
        required failure to occur.
    </p>
    <p>
        And you need for all of this to work in isolated, sandboxed test environments
        such as Travis-CI. So no clusters of local web servers serving up fixed
        responses to known requests. Indeed you can't even depend on there being
        any other hosts at all.
    </p>
    <h2>Mocking HTTP Conversations</h2>       
    <p>
        We use the mocking feature of our <a href="https://github.com/webignition/http-client">HTTP client library</a>
        to ensure that code executing under unit tests receives consistent HTTP responses or
        encounters consistent HTTP failure conditions.
    </p>
    <p>
        The mock HTTP client is isolated from everything and is aware of nothing
        unless told about it. It's not aware of the Internet and, by default,
        is unable to find any resource requested of it.
    </p>
    <pre class="prettyprint lang-php">&lt;?php
use webignition\Http\Mock\Client\Client as HttpClient;

$request = new \HttpRequest('http://blog.simplytestable.com/');

$httpClient = new HttpClient();

$response = $httpClient->getResponse($request);
print $response->getResponseCode(); // 404
    </pre>
    <p>
        If you need a <code>200 Ok</code> accompanied by some meaninful
        content, you need to tell the HTTP client in advance the response you
        want back for a request:
    </p>
    <pre class="prettyprint lang-php">&lt;?php
use webignition\Http\Mock\Client\Client as HttpClient;

$request = new \HttpRequest('http://blog.simplytestable.com/');

$httpClient = new HttpClient();
$httpClient->getRequestReponseList()->set(
    $request,
    new \HttpMessage("HTTP/1.1 200 Ok\n\nHello World!")
);

$response = $httpClient->getResponse($request);
print $response->getResponseCode(); // 200
print $response->getBody(); // Hello World!
    </pre>
    <p>
        This is great if you have a request object to hand and a response object 
        to match. If you're expecting a chain of <code>301</code> responses to be followed,
        you're unable to control the automatic generation of requests to follow 
        such redirects.        
    </p>
    <p>
        If you know the essence of the request that will be made, you can tie in a
        response to a known HTTP command:
    </p>
    <pre class="prettyprint lang-php">&lt;?php
use webignition\Http\Mock\Client\Client as HttpClient;

$request = new \HttpRequest('http://blog.simplytestable.com/gets-301-response');

$httpClient = new HttpClient();
$httpClient->getCommandReponseList()->set(
    $request,
    new \HttpMessage("HTTP/1.1 301 Moved Permanently
                      Location: http://blog.simplytestable.com/destination")
);
$httpClient->getCommandResponseList()->set(
    "GET http://blog.simplytestable.com/destination",
    new \HttpMessage("HTTP/1.1 200 Ok\n\nHello Again!")
);

$response = $httpClient->getResponse($request);
print $response->getResponseCode(); // 200
print $response->getBody(); // Hello Again!
    </pre> 
    <p>
        The <a href="https://github.com/webignition/http-client/blob/master/src/webignition/Http/Mock/ResponseList/RequestResponseList.php">RequestResponseList</a>
        lets you specify directly responses for <code>\HttpRequest</code> objects
        that just so happen to be lying around. The <a href="https://github.com/webignition/http-client/blob/master/src/webignition/Http/Mock/ResponseList/CommandResponseList.php">CommandResponseList</a>
        lets you specify directly responses for HTTP commands you know are to be 
        issued.
    </p>
    <p>
        This is great if you happen to have a HttpClient object to hand to
        which you can feed responses for requests or HTTP commands known to happen.
    </p>
    <p>
        When running unit tests you know the test data that is to be sent in 
        requests and you know the responses you want to receive back but without being
        able to modify the application logic you can't tell the HttpClient
        directly the responses to use.
    </p>  
    <p>
        The <a href="https://github.com/webignition/http-client/blob/master/src/webignition/Http/Mock/ResponseList/StoredResponseList.php">StoredResponseList</a>
        solves this.
    </p>
    <p>
        You pass the StoredResponseList the path to HTTP message fixtures to be used.
        Each fixture is the plain text of an <code>\HttpMessage</code> stored in a
        file named the same as the corresponding request's hash.
    </p>
    <p>
        The request's what? The hash. It's a hash of a request, unique to a request and something
        that fits comfortably into a filename.
    </p>
    <pre class="prettyprint lang-php">&lt;?php
use webignition\Http\Mock\Client\Client as HttpClient;

$request = new \HttpRequest('http://blog.simplytestable.com/');

$httpClient = new HttpClient();
$httpClient->getStoredResponseList()->setFixturesPath(
    '/home/example/fixtures/cda711beab03b2677abd1b15ed4d1114'
);

$response = $httpClient->getResponse($request);
print $response->getResponseCode(); // 200
print $response->getBody(); // Hello World!
    </pre> 
    <p>
        The file <code>/home/example/fixtures/cda711beab03b2677abd1b15ed4d1114</code>
        contains:
    </p>
    <pre class="prettyprint lang-php">HTTP/1.1 200 Ok

Hello World!</pre>
    <p>
        Guessing the right hash is tricky. When developing your tests you will
        know the HTTP requests that will issued and can ask the mock client
        to tell you where to store your fixtures:
    </p>
    <pre class="prettyprint lang-php">&lt;?php
use webignition\Http\Mock\Client\Client as HttpClient;

$request = new \HttpRequest('http://blog.simplytestable.com/');

$httpClient = new HttpClient();
$httpClient->getStoredResponseList()->setFixturePath('/home/example/HttpResponses');
print $httpClient->getStoredResponseList()->getRequestFixturePath($request);
// /home/example/HttpResponses/cda711beab03b2677abd1b15ed4d1114
    </pre>     
    <h2>Mocking Failure Conditions</h2>
    <p>
        We can return known responses to known requests but we also need things
        to break in known ways.
    </p>
    <p>
        The mock HTTP client similates failed DNS lookups, with
        simulated timeouts and simulated invalid URL cases to follow.
    </p>
    <p>
        The <a href="https://github.com/webignition/http-client/blob/master/src/webignition/Http/Client/Client.php">regular HTTP client</a>
        throws a <a href="https://github.com/webignition/http-client/blob/master/src/webignition/Http/Client/CurlException.php">CurlException</a>
        if a response contains a CURL code of anything other than zero.
    </p>
    <p>
        The mock HTTP client achieves the same by using the
        <a href="https://github.com/webignition/http-client/blob/master/src/webignition/Http/Mock/Client/CurlExceptionFactory.php">CurlExceptionFactory</a>
        to throw pre-determined exceptions when requesting specified URLs:
    </p>
    <p>
        The mock HTTP client defaults to knowing all hosts and will never
        encouter a DNS lookup failure. This is what you want for the 
        majority of your unit tests.
    </p>
    <p>
        You can tell the HTTP client that it knows no hosts, resulting
        in DNS lookup failure exceptions for all requests. Or, slightly more
        usefully, you can tell the client which hosts it knows, causing DNS lookup
        failure exceptions to occur for all other hosts.
    </p>
    <pre class="prettyprint lang-php">&lt;?php
use webignition\Http\Mock\Client\Client as HttpClient;

$request = new \HttpRequest('http://blog.simplytestable.com/');

$httpClient = new HttpClient();        
$httpClient->setKnowsSpecifiedHostsOnly();
$httpClient->setKnownHost('example.com');     

try {
    $response = $httpClient->getResponse($request);
} catch (CurlException $curlException) {            
    // We'll end up here as the client can't lookup blog.simplytestable.com
}
    </pre>
    <h2>Tying This Into Testable HTTP Applications And Test Environments</h2>
    <p>
        You application code needs to be testable with no test-specific logic paths
        and you need to be able to reach into your application code during unit
        tests to fake HTTP conversations that would otherwise be very real.
    </p>
    <p>
        I ensure all classes that need to make HTTP requests have a settable <code>httpClient</code>
        property. If this is accessed before being set, it is set to a regular
        HTTP client. It is then up to the test environment to set the <code>httpClient</code>
        property to a mock HTTP client with specified fixture path before
        and requests are made.
    </p>
    <p>
        <a href="http://symfony.com/">Symfony</a> services make this very easy. A
        <code>httpClient</code> service is defined and is injected into whichever
        other services require it when they are instantiated. The test environment 
        uses <a href="https://github.com/webignition/app.simplytestable.com/blob/master/src/SimplyTestable/ApiBundle/Resources/config/services_test.yml">a test-specific service definition</a>
        which simply specifies that the <code>httpClient</code> service use the mock HTTP client
        class.
    </p>
    <p>
        So long as any class that has a <code>httpClient</code> property passes
        this on to any service it makes use of that has a <code>setHttpClient()</code>
        method, the real or mock HTTP client will get passed as far down into
        the application as is needed.
    </p>
    <p>
        The same application logic runs for all environments and knows nothing about,
        and doesn't need to care about, how the HTTP client it possesses implements
        the retrieval of responses for requests.
    </p>
    <p>
        Application code can be unit tested quickly and reliably with no need to mess
        about within the application internals to get this to work.
    </p>
</div>