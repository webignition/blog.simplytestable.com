---
layout: default
title: "Integrating Resque Into A Symfony Application"
author:
    name: Jon Cram
    url: http://webignition.net
---

<div class="section">
    <h2>Getting Started With Symfony and Resque</h2>
    <p>
        We use a job system to handle the queuing and running of tasks 
        asychronously with respect to the application flow. Actions that could
        get in the way of things running smoothly and which don't mind when they
        happen are put into a queue to be run later.
    </p>    
    <p>
        This covers tasks such as the core application verifying a worker's activation
        request, expanding a new test job into a set of test tasks or farming out
        test tasks to eager hungry workers.
    </p>
    <p>
        For this we use a PHP port of <a href="https://github.com/defunkt/resque/">Resque</a>
        describes itself as being:
    </p>
    <blockquote>
        <p>
         a Redis-backed library for creating background jobs, placing those jobs on
         multiple queues, and processing them later
        </p>
    </blockquote>
    <p>
        We also use the <a href="http://symfony.com/">Symfony framework</a> for the
        core application and workers.
    </p>
    <p>
        Here's what I did to get the two working together.
    </p>
    <h2>Preparation</h2>
    <p>
        Resque is backed by Redis, and so we need to get this up and running first:   
    </p>
    <p>
        <code>sudo apt-get install redis-server</code>
    </p>    
    <p>
        Right, that was easy.
    </p>    
    <h2>Installing ResqueBundle: Resque With Symfony Integration Built In</h2>
    <p>
        We need the Resque library and we need to get this to understand where
        to look within our Symfony application to find the classes defining the
        jobs to be run.
    </p>
    <p>
        <a href="https://github.com/wpottier">William Pottier</a>, who maintains
        a fork of an existing PHP resque port, created also the
        <a href="https://github.com/glit/ResqueBundle">ResqueBundle</a> package 
        for Symfony, making integrating the two far too easy.
    </p>
    <p>
        Just update your dependency configuration:
    </p>
    <pre class="prettyprint lang-js">"require": {
    "glit/resque-bundle":"*"
},</pre>
    <p>
        And update your dependencies: <code>php composer.phar update</code>
    </p>
    <p>
        And then register the bundle in <code>app/AppKernel.php</code>:
    </p>
    <pre class="prettyprint lang-php">$bundles = array(
    // ...
    new Glit\ResqueBundle\GlitResqueBundle(),
);</pre>
    <p>
        And then add an prefix configuration value, either directly in
        <code>app/config/parameters.yml</code> or in your application bundle's
        <code>Resources/config/parameters.yml</code>
    </p>
    <pre class="prettyprint lang-yaml">glit_resque:
  prefix: "prefix_value"</pre>
    <p>
        The prefix can be anything you like. It's a namespace prefix used by Redis
        to differentiate between different applications that may be using the same
        Redis server. Your application bundle's namespace would be a good choice.
    </p>
    <p>
        That's it, you're ready to start using Resque.
    </p>
    <h2>
        Resque Fundamentals: Jobs, Queues and Workers
    </h2>
    <p>
        Resque lets you place <em>jobs</em> in <em>queues</em> to later be processed
        by <em>workers</em>. Jobs are placed into a queue. Later on a worker comes
        along, picks jobs out of a queue and runs them.
    </p>
    <p>
        It's the same work pattern we use across the Simply Testable system.
    </p>
    <p>
        Let's start by getting a worker process running. To begin with it will be
        processing queues containing no jobs, but that doesn't matter. We'll add
        jobs later.
    </p>
    <pre class="prettyprint lang-bash">$ php app/console resque:worker --daemon
Worker started as daemon.
</pre>
    <p>
        We now have one worker daemon running, eagerly awaiting jobs to run.
    </p>
    <h2>Creating a Job</h2>
    <p>
        A job, in the world of Resque, is just a class that follows certain patterns.
        Conceptually this is to the processing of work what a unit test is to the
        testing of code.
    </p>
    <p>
        Your job class must have a <code>perform()</code> method and can optionally
        have <code>setUp()</code> and <code>tearDown()</code> methods that are run,
        respectively, before and after the <code>perform()</code> method is called.
    </p>
    <p>
        Here's one I literally made a few minutes ago:
    </p>
    <pre class="prettyprint lang-php">&lt;?php
namespace SimplyTestable\ApiBundle\Resque\Job;

use SimplyTestable\ApiBundle\Exception\JobPrepareException;

class JobPrepareJob extends AbstractJob {    
    
    public function perform() {
        $output = array();
        $returnValue = null;
        $command = 'php app/console simplytestable:job:prepare ' . $this->args['id'];
        
        exec($command, $output, $returnValue);
        
        if ($returnValue !== 0) {
            throw new JobPrepareException(implode("\n", $output), $returnValue);
        }
    }    
}</pre>
    <p>
        You'll notice that a <code>JobPreparationException</code> is thrown if the
        command line command does not return what we expect. Resque fails a job
        if an exception is thrown which is exactly what we want to happen.
    </p>
    <h2>
        Queueing a Job
    </h2>
    <p>
        So we have a worker busily sitting there processing nothing, we have a job
        class defined. All that is left is to put jobs into the queue to make
        things happen.
    </p>
    <p>
        We need to get hold of a Resque queue and add a job to it. The <code>ResqueBundle</code>
        injects a queue manager service into the service container to make this
        available to us.
    </p>
    <p>
        In the Simply Testable core application, the <code>TestsController</code>
        handles the request to start or examine test jobs. This is where we need to
        add a new job to the Resque queue to later have that new test job
        expanded into a collection of test tasks to be passed to workers.
    </p>
    <pre class="prettyprint lang-php">$this->container->get('glit_resque.queue_manager')->add(
    'SimplyTestable\ApiBundle\Resque\Job\JobPrepareJob',
    'job-prepare',
    array(
        'id' => $job->getId()
    )
);</pre>
    <p>
        If I now request <code>http://dev.app.simplytestable.com/tests/http://webignition.net/start</code>
        to start a new test job and then examine the Resque logs:
    </p>
    <pre class="prettyprint">** [23:37:48 2012-08-08] Checking job-prepare
** [23:37:48 2012-08-08] Sleeping for 5
** [23:37:58 2012-08-08] Checking job-prepare
** [23:37:58 2012-08-08] Found job on job-prepare
** [23:37:58 2012-08-08] got (Job{job-prepare} | ID: 650b7e7a5ee6a21cbc3f1e1de750e1ab | SimplyTestable\ApiBundle\Resque\Job\JobPrepareJob | [{"id":10}])
** [23:37:58 2012-08-08] Forked 4477 at 2012-08-08 23:37:58
** [23:37:58 2012-08-08] Processing job-prepare since 2012-08-08 23:37:58
** [23:37:59 2012-08-08] done (Job{job-prepare} | ID: 650b7e7a5ee6a21cbc3f1e1de750e1ab | SimplyTestable\ApiBundle\Resque\Job\JobPrepareJob | [{"id":10}])
** [23:37:59 2012-08-08] Checking job-prepare
** [23:37:59 2012-08-08] Sleeping for 5
</pre>
    <p>
        The Resque job to prepare the test job is processed by the worker we set
        going. The test job has been expanded into a set of test tasks and this
        has safely happened asychronously with respect to the request to start
        a new test being received.
    </p>
    <p>
        If that seems easy, it's because it is. I made the <a href="https://github.com/webignition/app.simplytestable.com/compare/18ee0e8c4242...e16c582278ca">relevant changes to the
        core application</a> in the space of about half an hour whilst writing this
        post. You can't get much easier than that.
    </p>    
</div>